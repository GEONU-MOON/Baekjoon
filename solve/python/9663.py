def dfs(n):
    global ans
    if n == N:  # N행까지 진행한 경우 경우의 수 가능: 성공
        ans += 1
        return

    for j in range(N):
        if v1[j] == v2[n + j] == v3[n - j] == 0:  # 열/대각선 모두 퀸이 없는 경우
            v1[j] = v2[n + j] = v3[n - j] = 1  # 현재 위치에 퀸을 배치함
            dfs(n + 1)  # 다음 행으로 이동하여 재귀 호출
            v1[j] = v2[n + j] = v3[n - j] = 0     # 백트래킹: 현재 위치의 퀸을 제거하여 다른 위치에 퀸을 배치하기 위해
                                                  # 이전 상태로 되돌림

N = int(input())  # 입력으로 체스판의 크기 N을 받음
ans = 0  # 해의 개수를 저장할 변수 초기화
v1 = [0] * N  # 세로 방향의 퀸 배치를 나타내는 리스트 초기화
v2 = [0] * (2 * N)  # 오른쪽 아래 대각선 방향의 퀸 배치를 나타내는 리스트 초기화
v3 = [0] * (2 * N)  # 왼쪽 아래 대각선 방향의 퀸 배치를 나타내는 리스트 초기화
dfs(0)  # DFS 탐색 시작
print(ans)  # 가능한 해의 개수 출력
